namespace GdaxPrototyping.Applications.GdaxFixApiFacadePrototype
{
   /// <summary>
   /// todo Comments are broken all over here. Many come from other projects and their cross-links are broken.
   /// 
   /// todo.2 Copy some patterns from {TOmsConnectorBase}, such as {Prepare}.
   /// todo.2 Actually I took a look at it but decided to not copy that.
   /// </summary>
   [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
   public abstract class TFixInitiatorApplicationBase:
      TFixLogger,

      // todo.1 Try to comment and cross-ref about all this {....IDisposable} thing.
      // yg? System.IDisposable,

      QuickFix.IApplication
   {
      #region Data.

      private readonly QuickFix.Transport.SocketInitiator FixSocketInitiator_;
      private QuickFix.Session FixSession_;
      private bool ShallBeLoggedIn_;
      private bool IsTryingToBeLoggedIn_;
      private bool ShallEnsureIsLoggedOut_;
      private bool IsChangingLogInStatus_;
      public event Common.Core.ObjectModel.TInsecureAction LoggedInEvent;
      public event Common.Core.ObjectModel.TInsecureAction LoggedOutEvent;
      public event Common.Core.ObjectModel.TInsecureAction< QuickFix.Message > SendingSessionFixMessageEvent;
      public event Common.Core.ObjectModel.TInsecureAction< QuickFix.Message > SendingApplicationFixMessageEvent;
      public event Common.Core.ObjectModel.TInsecureAction< QuickFix.Message > ReceivedSessionFixMessageEvent;
      public event Common.Core.ObjectModel.TInsecureAction< QuickFix.Message > ReceivedApplicationFixMessageEvent;

      #endregion

      #region // {protected} Instance default constructor.

      // Cannot be autogenerated.

      #endregion
      #region {protected} Instance constructor.

      /// <summary>
      /// todo.1 {name1} should ideally be taken from a configuration object.
      /// </summary>
      protected TFixInitiatorApplicationBase
         ( string name1,
            QuickFix.SessionSettings fixSessionSettings
         ):
         base(name1)
      {
         //Name = name1;
         FixSocketInitiator_ =
            new QuickFix.Transport.SocketInitiator
               ( this,
                  Common.Core.StaticData.TStaticSingletonObjectContainer< QuickFix.MemoryStoreFactory >.Object,
                  fixSessionSettings,
                  this,//new TFixLogger(name1),
                  Common.Core.StaticData.TStaticSingletonObjectContainer< QuickFix.DefaultMessageFactory >.Object
               );
      }

      #endregion

      #region {public Dispose}.
      //#region {public System.IDisposable.Dispose}.

      /// <summary>
      /// todo.1 Is this comment relevant here?
      /// yg? Comment201705051 applies.
      /// </summary>
      public /*new*/ /*virtual*/ void Dispose()
      //new void System.IDisposable.Dispose()
      {
         //((QuickFix.ILog)(TFixLogger) this).Dispose();
         //((QuickFix.ILog) this).Dispose();

         ReceivedApplicationFixMessageEvent = null;
         ReceivedSessionFixMessageEvent = null;
         SendingApplicationFixMessageEvent = null;
         SendingSessionFixMessageEvent = null;
         LoggedOutEvent = null;
         LoggedInEvent = null;
         AsyncLogOutIfNeeded();
      }

      #endregion

      #region {public QuickFix.IApplication.OnCreate}.

      public /*virtual*/ void OnCreate
         ( QuickFix.SessionID fixSessionId
         )
      {
      }

      #endregion
      #region {public QuickFix.IApplication.OnLogon}.

      public /*virtual*/ void OnLogon
         ( QuickFix.SessionID fixSessionId
         )
      {
         try
         {
            System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);

            // Comment201704186 relates.
            System.Diagnostics.Debug.Assert(FixSession_ is null);

            // yg? Given that QuickFix is a piece of crap, this condition will not necessarily work well.
            // todo.1 Should I really comment the above?
            if(ShallBeLoggedIn_ && IsTryingToBeLoggedIn_ && (! ShallEnsureIsLoggedOut_))

            {
               // yg? Comment201704152 applies.
               QuickFix.Session fixSession = QuickFix.Session.LookupSession(fixSessionId);

               //// <Comment201704186>
               //// Let's double-check this, just in case...
               //// </Comment201704186>
               //System.Diagnostics.Debug.Assert(FixSession_ is null);

               if(! (fixSession is null))
               {
                  FixSession_ = fixSession;
                  LoggedInEvent?.Invoke();
               }
               else
               {
               }
            }
            else
            {
            }

            System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
         }
         catch(System.Exception exception)
         {
            System.Environment.FailFast(null, exception);
         }
      }

      #endregion
      #region {public QuickFix.IApplication.OnLogout}.

      public /*virtual*/ void OnLogout
         ( QuickFix.SessionID fixSessionId
         )
      {
         try
         {
            System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            System.Diagnostics.Debug.Assert
               (FixSession_ is null || fixSessionId as object == FixSession_.SessionID as object);

            if(! (FixSession_ is null))
            {
               FixSession_ = null;
               LoggedOutEvent?.Invoke();
            }
            else
            {
            }

            System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
         }
         catch(System.Exception exception)
         {
            System.Environment.FailFast(null, exception);
         }
      }

      #endregion
      #region {public QuickFix.IApplication.ToAdmin}.

      /// <summary>
      /// <Comment201802111>
      /// yg? For this and any other {virtual} methods, we might need a non-virtual method
      /// yg? named {NakedToAdmin} that will not do any exception handling. {override}s will need to call it.
      /// yg? Mark the non-naked method "obsolete".
      /// todo Reference this idea from UFX.
      /// </Comment201802111>
      /// </summary>
      public /*virtual*/ void ToAdmin
         ( QuickFix.Message fixMessage,
            QuickFix.SessionID fixSessionId
         )
      {
         try
         {
            System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            MyToAdmin(fixMessage);
            SendingSessionFixMessageEvent?.Invoke(fixMessage);
            System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
         }
         catch(System.Exception exception)
         {
            System.Environment.FailFast(null, exception);
         }
      }

      #endregion
      #region {protected MyToAdmin}.

      /// <summary>
      /// todo.1 Reconcile with Comment201802111. Maybe name this "naked".
      /// </summary>
      protected virtual void MyToAdmin
         ( QuickFix.Message fixMessage
         )
      {
      }

      #endregion
      #region {public QuickFix.IApplication.ToApp}.

      public /*virtual*/ void ToApp
         ( QuickFix.Message fixMessage,
            QuickFix.SessionID fixSessionId
         )
      {
         try
         {
            System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            MyToApp(fixMessage);
            SendingApplicationFixMessageEvent?.Invoke(fixMessage);
            System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
         }
         // todo.1 Comment near {MyToApp} about this. Assuming that only {MyToApp} can throw this. Otherwise this code will not necessarily work.
         catch(QuickFix.DoNotSend)
         {
            try
            {
               System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
            }
            catch(System.Exception exception)
            {
               System.Environment.FailFast(null, exception);
            }

            throw;
         }
         catch(System.Exception exception)
         {
            System.Environment.FailFast(null, exception);
         }
      }

      #endregion
      #region {protected MyToApp}.

      /// <summary>
      /// todo.1 Reconcile with Comment201802111. Maybe name this "naked".
      /// </summary>
      protected virtual void MyToApp
         ( QuickFix.Message fixMessage
         )
      {
         // This can throw {QuickFix.DoNotSend}.
         // yg? Comment201704146 applies.
         ProcessFixMessagePossibleReSend(fixMessage);
      }

      #endregion
      #region {private ProcessFixMessagePossibleReSend}.

      /// <summary>
      /// <Comment201704146>
      /// yg? This is questionable.
      /// </Comment201704146>
      /// todo --- yg? Should this be renamed to {ThreadSafe...}? Done. But only the logging is thread safe.
      /// todo Should this be {virtual}? I can make only the additional resend condition virtual.
      /// </summary>
      private static void ProcessFixMessagePossibleReSend
         ( QuickFix.Message fixMessage
         )
      {
         if( fixMessage.Header.IsSetField(QuickFix.Fields.Tags.PossDupFlag) &&

              // It's probably safe to assume that this will not throw an exception.
              fixMessage.Header.GetBoolean(QuickFix.Fields.Tags.PossDupFlag)
           )
         {
            //System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            Common.Core.Diagnostics.TLoggingHelpers.LogLogRecord(@"Error; throwing a {QuickFix.DoNotSend} exception");
            //System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
            throw new QuickFix.DoNotSend();
         }
         else
         {
         }
      }

      #endregion
      #region {public QuickFix.IApplication.FromAdmin}.

      public /*virtual*/ void FromAdmin
         ( QuickFix.Message fixMessage,
            QuickFix.SessionID fixSessionId
         )
      {
         try
         {
            System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            ReceivedSessionFixMessageEvent?.Invoke(fixMessage);
            System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
         }
         catch(System.Exception exception)
         {
            System.Environment.FailFast(null, exception);
         }
      }

      #endregion
      #region {public QuickFix.IApplication.FromApp}.

      public /*virtual*/ void FromApp
         ( QuickFix.Message fixMessage,
            QuickFix.SessionID fixSessionId
         )
      {
         try
         {
            System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            ReceivedApplicationFixMessageEvent?.Invoke(fixMessage);
            System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
         }
         catch(System.Exception exception)
         {
            System.Environment.FailFast(null, exception);
         }
      }

      #endregion

      #region {public ASyncRepeatedTryLogInIfNeeded}.

      public void ASyncRepeatedTryLogInIfNeeded()
      {
         if(ShallBeLoggedIn_)
         {
            return;
         }
         else
         {
         }

         ASyncRepeatedTryLogIn();
      }

      #endregion
      #region {public ASyncRepeatedTryLogIn}.

      public void ASyncRepeatedTryLogIn()
      {
         System.Diagnostics.Debug.Assert(! ShallBeLoggedIn_);
         ShallBeLoggedIn_ = true;
         ASyncChangeLogInStatusIfNeeded();
      }

      #endregion
      #region {public AsyncLogOutIfNeeded}.

      public void AsyncLogOutIfNeeded()
      {
         if(! ShallBeLoggedIn_)
         {
            return;
         }
         else
         {
         }

         AsyncLogOut();
      }

      #endregion
      #region {public AsyncLogOut}.

      public void AsyncLogOut()
      {
         System.Diagnostics.Debug.Assert(ShallBeLoggedIn_);
         ShallBeLoggedIn_ = false;
         ShallEnsureIsLoggedOut_ = IsTryingToBeLoggedIn_;
         ASyncChangeLogInStatusIfNeeded();
      }

      #endregion
      #region {private ASyncChangeLogInStatusIfNeeded}.

      private void ASyncChangeLogInStatusIfNeeded()
      {
         if(IsChangingLogInStatus_)
         {
            return;
         }
         else
         {
         }

         IsChangingLogInStatus_ = true;
         System.Threading.Thread​Pool.UnsafeQueueUserWorkItem(ThreadSafeChangeLogInStatusIfNeeded, null);
      }

      #endregion
      #region {private ThreadSafeChangeLogInStatusIfNeeded}.

      private void ThreadSafeChangeLogInStatusIfNeeded
         ( object dummy1
         )
      {
         System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);

         for(;;)
         {
            //bool bool1 = false;

            if(ShallEnsureIsLoggedOut_)
            {
               // At this point, it could make sense to do what {OnLogout} does, but keeping it simple.

               ShallEnsureIsLoggedOut_ = false;

               // todo.1 What is this is already {false}? No need to bother checking?
               // todo.1 This all needs to be revisited and verified.
               IsTryingToBeLoggedIn_ = false;

               System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
               FixSocketInitiator_.Stop();
               //bool1 = true;
               System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            }
            else
            {
            }

            if(ShallBeLoggedIn_ && (! IsTryingToBeLoggedIn_))
            {
               IsTryingToBeLoggedIn_ = true;
               System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);

               // todo.1 Would it be safe to call this within a critical section?
               // todo.1 Regardless...
               // todo.1 Comment in VUSS?
               FixSocketInitiator_.Start();

               // todo.1 Sleep for some 6 seconds here? Bcause otherwise it will be possible to call {....Stop} immediately, which QuickFix will probably not handle well.

               //bool1 = true;
               System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            }
            else
            {
               break;
            }

            //if(! bool1)
            //{
            //   break;
            //}
            //else
            //{
            //}
         }

         IsChangingLogInStatus_ = false;
         System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
      }

      #endregion
      #region {public IsLoggedIn}.

      public bool IsLoggedIn
      {
         get
         {
            return (! (FixSession_ is null));
         }
      }

      #endregion

      #region {public TrySendFixMessage}.

      /// <summary>
      /// todo.1 ??? I named this "thread safe" because our hacked modification of QuickFix locks our main lockable internally.
      /// </summary>
      //public void ThreadSafeTrySendFixMessage
      public void TrySendFixMessage
         ( QuickFix.Message fixMessage
         )
      {
         // yg? Should we validate that we are logged in? Comment near the whole method.
         // yg? QuickFix actually alows to send while not logged in, right?

         try
         {
            // <Comment201704084>
            // yg? If this is {null} we won't save the message for further resend.
            // yg? Would it make sense to return -1 in that case
            // yg? and +1 in case this returns {false} or throws an exception?
            // yg? This way, -1 would indicate that the message wasn't saved for further resend.
            // yg? If {....DoNotSend} is thrown this would return {false}, but we would need to return -1,
            // yg? but at this point we can't know about that.
            // yg? Comment201704088 relates.
            // yg? Comment201704083 relates.
            // </Comment201704084>
            // <Comment201705169>
            // yg? If this is {null}, the {MsgSeqNum} field will not be added to {fixMessage}.
            // yg? This all needs to be revisited.
            // </Comment201705169>
            // Non-volatile read. Assuming that a read introduction will not happen here.
// todo This is implied to be not null.
// todo What exceptions does this throw?
            //FixSession_?.Send(fixMessage);
            FixSession_.Send(fixMessage);
         }

         // yg? Comment201704088 relates.
         catch(System.IO.IOException ioException)

         {
            //System.Threading.Monitor.Enter(Common.Core.Threading.TThreadingHelpers.MainLockable);
            Common.Core.Diagnostics.TLoggingHelpers.LogLogRecord(ioException);
            //System.Threading.Monitor.Exit(Common.Core.Threading.TThreadingHelpers.MainLockable);
         }
      }

      #endregion
   }
}
