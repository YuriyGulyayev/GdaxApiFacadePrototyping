namespace GdaxPrototyping.Applications.GdaxFixApiFacadePrototype.GdaxFixApiFacade
{
   [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
   public sealed class TFixInitiatorApplication:
      TFixInitiatorApplicationBase
   {
      #region // {public} Instance default constructor.

      // Cannot be autogenerated.

      #endregion
      #region {public} Instance constructor.

      public TFixInitiatorApplication
         ( string name1,
            QuickFix.SessionSettings fixSessionSettings
         ):
         base(name1, fixSessionSettings)
      {
      }

      #endregion

      #region {protected MyToAdmin}.

      protected override void MyToAdmin
         ( QuickFix.Message fixMessage
         )
      {
         base.MyToAdmin(fixMessage);

         if(fixMessage is QuickFix.FIX42.Logon logOnFixMessage)
         {
            //// See Comment201802141.
            //const string key = @"...";

            const string secret = @"TJQB9lIMO6yVjnjU9KPx0x0rYhDU2whlWPQwRGpV/x9Yz6IL/01LY1TRkE3akmFB4OEcTSYlJ4PQMuGPM2Absw==";
            const string passphrase = @"zhbpeqszjiyc";

            {
               string signature =
                  CreateAccessSign
                     ( fixMessage.Header.GetString(QuickFix.Fields.Tags.SendingTime),
                        QuickFix.FIX42.Logon.MsgType,
                        fixMessage.Header.GetString(QuickFix.Fields.Tags.MsgSeqNum),

                        // todo This is key, right? It's known in advance, right? See Comment201802141.
                        fixMessage.Header.GetString(QuickFix.Fields.Tags.SenderCompID),

                        // todo This is known in advance, right?
                        fixMessage.Header.GetString(QuickFix.Fields.Tags.TargetCompID),

                        passphrase,
                        secret
                     );
               logOnFixMessage.RawData = new QuickFix.Fields.RawData(signature);
            }

            logOnFixMessage.SetField(new QuickFix.Fields.Password(passphrase));
         }
         else
         {
         }
      }

      #endregion
      #region {private CreateAccessSign}.

      private static string CreateAccessSign
         ( string sendingTime,
            string msgType,
            string msgSeqNumber,
            string senderCompId,
            string targetCompId,
            string passphrase,
            string secret
         )
      {
         var stringToHash = string.Join(@"\x01", sendingTime, msgType, msgSeqNumber, senderCompId, targetCompId, passphrase);
         var privateKeyAsBytes =
            //Encoding.UTF8.GetBytes
            //Encoding.ASCII.GetBytes
            System.Convert.FromBase64String
               //("privateKey");
               (secret);

         using(var hmac = new System.Security.Cryptography.HMACSHA256(privateKeyAsBytes))
         {
            byte[] signature = hmac.ComputeHash(System.Text.Encoding.ASCII.GetBytes(stringToHash));
            return System.Convert.ToBase64String(signature);
         }
      }

      #endregion
   }
}
